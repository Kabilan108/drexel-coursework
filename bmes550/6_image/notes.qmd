---
title: "Object-Oriented Image Processing"
author: "Tony Kabilan Okeke"
format:
    html:
        fig-width: 4
        toc: true
        toc-depth: 3
        toc-title: "Contents"
        toc-location: left
        code-fold: false
        theme: sandstone
comments: 
    hypothesis: true
jupyter: python3
---

```{python}
#| echo: false
# Import libraries
import matplotlib.pyplot as plt
import numpy as np
import requests
import skimage
import shutil
import cv2
import re
from pathlib import Path
from skimage import io
from tqdm.auto import tqdm


# Load bmes.ahmet
import sys, os
sys.path.append(os.environ['BMESAHMETDIR'])
import bmes
```

```{python}
#| echo: false
# Function definitions
def isnonemptyfile(file: str) -> bool:
    """
    Check if a file exists and is not empty
    """

    assert isinstance(file, str) or isinstance(file, Path), \
        'file must be a string'

    return os.path.isfile(file) and os.path.getsize(file) > 0


def downloadurl(url: str, file: str='', overwrite: bool=False,
                progress: bool=True) -> str:
    """
    Download and save file from a given URL
    Modified from bmes.downloadurl by Ahmet Sacan

    Parameters
    ----------
    url : str
        URL to retreive file from
    file : str, optional
        Path to file (or directory) where download will be stored,
        by default ''
    overwrite : bool, optional
        Should existing files be overwritten, by default False
    progress : bool, optional
        Should a progress bar be displayed, by default True

    Returns
    -------
    str
        Path to the downloaded file
    """

    # Check inputs
    assert isinstance(url, str), 'url must be a string'
    assert isinstance(file, str), 'file must be a string'
    assert isinstance(overwrite, bool), 'overwrite must be a boolean'

    # If URL is not a remote address, assume it is a local file
    if not re.search(r'^(http[s]?|ftp):\/\/', url):
        if not file:
            return url
        if not overwrite:
            if isnonemptyfile(file):  return file
            shutil.copyfile(url, file)
            return file

    # Get file name from URL and append to file path
    if not file:
        urlname = url.split('?')[0].split('/')[-1]
        file = (tempdir() / slugify(urlname)).resolve()  # type: ignore
    elif file.endswith('/'):
        file = (Path(file) / slugify(url)).resolve()  # type: ignore
    else:
        file = Path(file).resolve()  # type: ignore

    # Return file if it exists and overwrite is False
    if isnonemptyfile(file) and not overwrite:  return file

    # Download the file
    r = requests.get(url, stream=True, allow_redirects=True,
                     timeout=(3, 27))
    if r.status_code == 200:
        size = int(r.headers.get('content-length', 0))
        
        # Create a progress bar
        if progress:
            with open(file, 'wb') as f:
                with tqdm(
                    total=size, 
                    unit='B', 
                    unit_scale=True, 
                    desc=file.name,  # type: ignore
                    initial=0
                ) as pbar:
                    for chunk in r.iter_content(chunk_size=1024):
                        if chunk:
                            f.write(chunk)
                            pbar.update(len(chunk))
        else:
            with open(file, 'wb') as f:
                for chunk in r.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)

    elif r.status_code == 404:
        raise Exception('URL not found')
    else:
        raise Exception('Unexpected error, status code: ' +
                        str(r.status_code))

    return file
```


## Set-Up

First, let's download some images to work with.

```{python}
#| echo: true
#| fig-cap: "Sample microscopy image"
# Dowload a sample image
URL = ''.join(['http://sacan.biomed.drexel.edu/lib/exe/fetch.php?'
               'media=course:bcomp2:img:samplecells.jpg'])
imfile = downloadurl(URL,'img/samplecells.jpg')

# Show the image
img = io.imread(imfile)
io.imshow(img);
```


## Image Segmentation

Image segmentation helps to obtain the region of interest (ROI) from an image.
It involves separating an image into different regions called **Image Objects**
based on image properties including similarity, discontinuity, etc. The goal of
image segmentation is the simplification of the original image to aid analysis.  

![Segmentation Approaches](img/segmentation-approaches.png)

::: {.callout-note}
## Segmentation Algorithms
There are several algorithms available for performing image segmentation. Here,
we will explore the following:

* [Threshold-based Segmentation](@sec-otsu)
* [Clustering-based Segmentation](@sec-cluster)
* [Watershed Segmentation](@sec-watershed)
* [Edge-based Segmentation](@sec-edge)
* [Region-based Segmentation](@sec-region)
* [Deep-Learing models for Segmentation](@sec-deeplearning)
:::


### Threshold-based Segmentation {#sec-otsu}

Image thresholding is the simplest kind of segmentation because it partitions
the image into two groups of pixels - white for the foregrounnd, black for the
background.  
Image thresholding can be further divided into **local** and **global**
thresholding algorithms. 

* For **global** thresholding, a single threshold is used across the whole
  image. Typically, these algorithms involve the following steps:
  1. Processing the input image
  2. Obtain the intensity histogram for the image
  3. Compute the threshold value, $T$ (Algorithms tend to differ here).
  4. Split the image into foreground ($saturation < T$) and background
     ($saturation > T$)
* For **local** thresholding, the characteristics of local image areas are used
  to determine different thresholds for different parts of the image.

#### Otsu's Thresholding

This algorithm process the intensity histogram, and segments the objects by
minimizing the variance of each of the classes. Usually, this technique produces
the appropriate results for **bimodal images** - the histogram of such images
contains two clearly expressed peaks, which represent different intensity
ranges.

This algorithm is not ideal for noisy images and is better suited to bimodal
images. Typically, Otsu segmentaion is emploed in scanning documents, pattern
recognition, cell segmentation, etc.

:::{.callout-note collapse="true"}
## Mathematical Foundations

The core idea involves separating the image histogram into two clusters with a
threshold defined as a result of minizing the within-class variance denoted by
$\sigma^2_w(t)$. The equation below describes the computation performed, where
$w_1(t),~w_2(t)$ are the probabilities of the two classes divided by a
threshold, $t \subset [0,255]$.
$$
\sigma^2_w(t) = w_1(t)\sigma^2_1(t) + w_2(t)\sigma^2_2(t)
$$

There are two options to find the threshold:

- Minimizing the within-class variance; 
- Maximizing the between-class variance (defined below; where $\mu_i$ is the
  mean of class $i$).
$$
\sigma^2_b(t) = w_1(t)w_2(t)\left[\mu_1(t) - \mu_2(t)\right]
$$

The probability $P$ is calculated for each pixel value in two separate clusters,
$C_1,~C_2$ using the cluster probability functions expressed as:
$$
\begin{align}
w_1(t) &= \sum_{i=1}^{t} P(i) \\
w_2(t) &= \sum_{i=t+1}^{I} P(i)
\end{align}
$$

Note that the image can bre represented as an intensity function, $f(x,y)$,
whose values are gray-levels. The quantity of pixels with a specified gray-level
$i$ is denoted by $i$. The general number of pixels in the image is $n$. Thus,
the probability of gray-level $i$ occurrence is:
$$
P(i) = \frac{n_i}{n}
$$

The pixel intensity values for $C_1$ are in $[1, t]$ and for $C_2$ are in
$[t+1, I]$, where $I$ is the maximum pixel value (255).

Next, we need to obtain the means for $C_1,~C_2$ which are denoted by
$\mu_1(t),~\mu_2(t)$:
$$
\begin{align}
\mu_1(t) &= \sum_{i=1}^{t} \frac{iP(i)}{w_1(t)} \\
\mu_2(t) &= \sum_{i=t+1}^{I} \frac{iP(i)}{w_2(t)}
\end{align}
$$

Next, we'll define the class variances:
$$
\begin{align}
\sigma_1^2(t) &= \sum_{i=1}^{t} \left[i - \mu_1(t)\right]^2 \frac{P(i)}{w_1(t)} \\
\sigma_2^2(t) &= \sum_{i=t+1}^{I} \left[i - \mu_2(t)\right]^2 \frac{P(i)}{w_2(t)}
\end{align}
$$

Note that if the threshold is chosen incorrectly, the variance of one of the
classes would be large. To get the total variance, we simply need to summarize
the within-class and between-class variances ($\sigma_T^2$ doesnt depend on $t$)
$$
\sigma^2_T = \sigma^2_w(t) + \sigma^2_b(t)
$$

Thus, the general algorithm for maximizing the between-class variance can be
represented as follows:

1. Calculate the histogram and intensity level probabilities
2. Initialize $w_i(0)$ and $\mu_i(t)$
3. Iterate over possible thresholds: $t=0,...,255$
  - Update the values of $w_i$ (probability) and $\mu_i$ (mean of class $i$)
  - Calculate the between-class variance, $\sigma_b^2$
4. The final threshold corresponds to the maximium $\sigma_b^2$ value.
:::


Here, we will implement Otsu's method. It will function similarly to
[`skimage.threshold_otsu`](https://github.com/scikit-image/scikit-image/blob/master/skimage/filters/thresholding.py#L237) which also maximizes the between calss variance.
The OpenCV impelmentation, on the other hand, [`getThreshVal_Otsu`](https://github.com/opencv/opencv/blob/master/modules/imgproc/src/thresh.cpp#L1129) minimizes the within class variance.

```{python}
#| echo: true
#| code-fold: true
#| code-line-numbers: true
#| code-summary: "Image loading and de-noising"

# Load a test image in grayscale
image = io.imread('img/boat.jpg', as_gray=True)
image2 = cv2.imread('img/boat.jpg', 0)

# Apply a GaussianBlur to reduce image noise
image = skimage.filters.gaussian(image, truncate=2)

io.imshow(image);
```


```{python}
#| echo: true
#| code-fold: false
#| code-line-numbers: true
#| code-summary: "Python Implementation of Otsu Segmentation"

# Define number of histogram bins
bins = 256

# Get the image histogram
hist, edges = np.histogram(image, bins=bins)

# Normalize the intensity histogram
hist = np.divide(hist.ravel(), hist.max())

# Calculate bin centers
centers = (edges[:-1] + edges[1:]) / 2.

# Iterate over all thresholds and calculate the probabilities w1(t) and w2(t)
weight1 = np.cumsum(hist)
weight2 = np.cumsum(hist[::-1])[::-1]

# Get the class means
mean1 = np.cumsum(hist * centers) / weight1
mean2 = (np.cumsum((hist * centers)[::-1]) / weight2[::-1])[::-1]

# Calculate the between-class variance
variance = weight1[:-1] * weight2[1:] * (mean1[:-1] - mean2[1:])**2

# Fnd the maximum variance
idx = np.argmax(variance)

# Determine the threshold
threshold = centers[:-1][idx]
print("Otsu's algorithm threshold:", threshold)
```


### Clustering-based Segmentation {#sec-cluster}


### Watershed Segmentation {#sec-watershed}


## Intensity-Based Image Registration

## Cell Detection in Microscopy Images

### Edge Detection and Morphology
